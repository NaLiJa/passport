kForceLower !byte $FF     ; AND mask for lowercase letters
                          ; (set at program startup)

;-------------------------------
; PrintByID
; Print a string from the string table;
; handles string substitutions and
; auto-uppercases on older machines
; in:  A = string ID
; out: X register preserved, others clobbered
;      all flags clobbered
;-------------------------------
PrintByID
         stx   .x+1
         ldy   #0         ; substitution mode flag
         tax
         lda   StringTableLow,x
         sta   @print+1
         lda   StringTableHigh,x
         sta   @print+2
@print
         lda   $FFFF      ; modified at runtime
         beq   .done
         cpy   #0         ; are we in substitution mode or include mdoe?
         bmi   .include   ; yes, include mode
         beq   @nosub     ; no -> branch
         ldy   #0
         cmp   #"t"       ; "%t" = current track
         bne   @sub1
         lda   gTrack
         bpl   @printbyte ; unconditional branch
@sub1
         cmp   #"s"       ; "%s" = current sector
         bne   @sub2
         lda   gSector
         bpl   @printbyte ; unconditional branch
@sub2
         cmp   #"S"       ; write slot
         bne   @sub3
         lda   SLOT
         bne   @printsd   ; unconditional branch
@sub3
         cmp   #"D"       ; write drive
         bne   @sub4
         lda   DRIVE
@printsd
         ora   #$80
         jsr   PrintA
         bvc   .next      ; unconditional branch
@sub4
         cmp   #"0"       ; "%0" through "%9"
         bcc   @nosub
         cmp   #":"
         bcs   @nosub
         sec
         sbc   #"0"
         tax
         lda   gDisplayBytes,x
@printbyte
         jsr   PrintByte
         bvc   .next      ; unconditional branch
@nosub
         cmp   #"%"
         bne   .stillnosub
         iny              ; Y=#$01 (substitution mode, next character will be interpreted)
         bne   .next      ; unconditional branch
.stillnosub
         cmp   #"@"
         bne   +
         dey              ; Y=#$FF (include mode, next character will be interpreted)
         bne   .next      ; unconditional branch
+        cmp   #$E1
         bcc   @noforce
         and   kForceLower
@noforce
         jsr   COUT
.next
         inc   @print+1
         bne   @print
         inc   @print+2
         bne   @print     ; unconditional branch
.done
.x       ldx   #$FD       ; SMC
         rts
.include
         sta   .a+1
         lda   @print+1
         pha
         lda   @print+2
         pha
         ldx   .x+1
.a       lda   #$FD       ; SMC
         jsr   PrintByID
         pla
         sta   @print+2
         pla
         sta   @print+1
         ldy   #0
         beq   .next      ; unconditional branch

;-------------------------------
; PrintByte
; print a hexadecimal byte
; in:  A contains byte to print
; out: all registers preserved
;      all flags clobbered
;      @tmpa clobbered
;      @tmpx clobbered
;      @tmpy clobbered
;-------------------------------
PrintByte
         jsr   SaveAXY
         jsr   PRBYTE
         jmp   LoadAXY

;-------------------------------
; PrintA
; print a single character through COUT
; in:  A contains character to print
; out: all registers preserved
;      all flags clobbered
;      @tmpa clobbered
;      @tmpx clobbered
;      @tmpy clobbered
;-------------------------------
PrintA
         jsr   SaveAXY
         jsr   COUT
         ; /!\ execution falls through here

LoadAXY
         lda   tmpa
         ldx   tmpx
         ldy   tmpy
         clv
         rts

SaveAXY
         sta   tmpa
         stx   tmpx
         sty   tmpy
         rts

;-------------------------------
; ClearScreen
;-------------------------------
ClearScreen
         jsr   TEXT
         lda   $C061
         bpl   .home
         lda   $C062
         bpl   .home
.begin
         ldx   #$04
         stx   counter
         stx   @loop+2
         stx   @change+2
         ldy   #$00
         sty   flag
@loop
         ldx   $FF00,y    ; modified at runtime
         cpx   #$A0
         beq   @nochange
         bcs   @down
         inx
         bne   @change
@down
         dex
@change
         txa
         sta   $FF00,y    ; modified at runtime
         sta   flag
@nochange
         iny
         bne   @loop
         inc   @loop+2
         inc   @change+2
         dec   counter
         bne   @loop
         lda   #$01
         jsr   WAIT
         lda   flag
         bne   .begin
.home
         jmp   HOME
