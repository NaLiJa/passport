;-------------------------------
; IDBootloader
; main entry point to identify the bootloader
; and exit via the appropriate tracer/copier
;
; in:    T00,S00 in memory at $0800
;-------------------------------
!zone {
IDBootloader

; reset all per-disk globals

         lda   #FALSE
         sta   gIsBoot0
         sta   gIsBoot1
         sta   gIsMaster
         sta   gIsRWTS
         sta   gIsProDOS
         sta   gIsPascal
         sta   gIsDatasoft
         sta   gIsProtDOS
         sta   gIsEA
         sta   gIsEEEF
         lda   #$00
         sta   gLastTrack

; Quick sanity check -- only recognized values for $0800
; are 1 or 2 for regular disks, and 5 for possible Electronic Arts.

         lda   $0800
         beq   +
         cmp   #$03
         bcc   ++
         cmp   #$05
         beq   ++
+
-        jmp   UseUniversal

++
;
; Copy the boot sector from $0800 to the track/sector buffer
; so we can reuse our standard compare functions.
;
         lda   #$08
         ldx   #BASEPAGE
         ldy   #$01
         jsr   CopyMemory

         lda   #$00
         ldx   #$00
         ldy   #$4A
         jsr   compare    ; if T00,S00,$00 ==

; This needs to be pretty strict because, if it matches,
; we're going to patch the sector and trace it to capture
; the RWTS.

         !byte $01,$A5,$27,$C9,$09,$D0,$18,$A5
         !byte $2B,$4A,$4A,$4A,$4A,$09,$C0,$85
         !byte $3F,$A9,$5C,$85,$3E,$18,$AD,$FE
         !byte $08,$6D,$FF,$08,$8D,$FE,$08,$AE
         !byte $FF,$08,$30,$15,$BD,$4D,$08,$85
         !byte $3D,$CE,$FF,$08,$AD,$FE,$08,$85
         !byte $27,$CE,$FE,$08,$A6,$2B,$6C,$3E
         !byte $00,$EE,$FE,$08,$EE,$FE,$08,$20
         !byte $89,$FE,$20,$93,$FE,$20,$2F,$FB
         !byte $A6,$2B
         ldx   #TRUE
         bcc   .boot0
         ldx   #FALSE
.boot0
         stx   gIsBoot0

         lda   #$00
         ldx   #$00
         ldy   #$05
         jsr   compare    ; if T00,S00,$00 ==

; This abbreviated signature matches all ProDOS disks
; I can find, with no false positives.
; Some disks jump to $08FF at $0804 (SOS entry point).
; Others have a modified T00,S00 but eventually load
; ProDOS (e.g. 1-2-3 Sequence Me, Alge-Blaster Plus,
; Dazzle Draw, SuperPrint II)

         !byte 01,$38,$B0,$03,$4C
         ldx   #TRUE
         bcc   .prodos
         ldx   #FALSE
.prodos
         stx   gIsProDOS

         lda   #$00
         ldx   #$00
         ldy   #$08
         jsr   compare    ; if T00,S00,$00 ==

; Apple Pascal signature (version < 1.3)
; The wildcard in 7th position catches alternate jump
; addresses (e.g. Wizardry I, Sundog Frozen Legacy)

         !byte $01,$E0,$60,$F0,$03,$4C,$97,$08
         ldx   #TRUE
         bcc   .pascal
         lda   #$00
         ldx   #$00
         ldy   #$08
         jsr   compare    ; or if T00,S00,$00 ==

; Pascal 1.3 signature [thanks Marco V.]

         !byte $01,$E0,$70,$B0,$04,$E0,$40,$B0
         ldx   #TRUE
         bcc   .pascal
         ldx   #FALSE
.pascal
         stx   gIsPascal

;
; Try to identify DOS 3.3-shaped bootloader, which
; we can maybe trace to capture the RWTS in memory.
;
         jsr   IDDOS33
         bcs   .notdos33
         lda   #s_dosb0
         jsr   PrintByID
         jmp   TraceDOS33

.notdos33
;
; Try to identify a variant bootloader that calls to $08B3
; early to munge the nibble tables used by the drive firmware.
;
         jsr   ID8b3
         bcs   .not8b3
         lda   #s_jsr8b3
         jsr   PrintByID
         jmp   Trace8B3

.not8b3
;
; Try to identify all the different MECC fastloader variants.
;
         jsr   IDMECC
         bcs   .notmecc
         lda   #s_mecc
         jsr   PrintByID
         jsr   CopyUniversal
         jsr   PrereadT00
         bcs   .notmecc
         jsr   IDMECC1
         bcs   .notmecc1
         jmp   foundmecc1
.notmecc1
         jsr   IDMECC2
         bcs   .notmecc2
         jmp   foundmecc2

.notmecc2
         jsr   IDMECC3
         bcs   .notmecc3
         jmp   foundmecc3
.notmecc3
         jsr   IDMECC4
         bcs   .notmecc4
         jmp   foundmecc4
.notmecc4
.notmecc
;
; Try to identify the encrypted Datasoft bootloader.
;
         jsr   IDDatasoft
         bcs   .notdatasoft
         lda   #s_datasoftb0
         jsr   PrintByID
         lda   #TRUE
         sta   gIsDatasoft
         jmp   .useuniv

.notdatasoft
;
; Try to identify ProDOS bootloader.
;
         lda   gIsProDOS
         bne   .notprodos
         lda   #s_prodosb0
         jsr   PrintByID
         jmp   .useuniv

.notprodos
;
; Try to identify Apple Pascal bootloader (all variants).
;
         lda   gIsPascal
         bne   .notpascal
         lda   #s_pascalb0
         jsr   PrintByID

.notpascal
         jsr   IDSpecDel
         bcs   .notspecdel
         lda   #s_specdel
         jsr   PrintByID
         jmp   TraceSpecDel

.notspecdel
;
; Try to detect whether there is code in the boot sector
; that loads 4-and-4-encoded data. This is an early escape
; hatch for disks that are guaranteed to fail later anyway.
;
         jsr   IDEncoded44
         bcs   .notencoded44
         lda   #s_encoded44
         jsr   PrintByID
         jmp   TheEnd

.notencoded44
;
; Try to detect whether there is code in the boot sector
; that loads 5-and-3-encoded data (like DOS 3.2 disks with
; a hybrid boot sector that loads on 16-sector drives).
; Passport has no support for converting DOS 3.2 disks, so
; this serves as an early escape hatch for disks that are
; guaranteed to fail later anyway.
;
         jsr   IDEncoded53
         bcs   .notencoded53
         lda   #s_encoded53
         jsr   PrintByID
         jmp   TheEnd

.notencoded53
;
; Try to identify Electronic Arts bootloader.
;
.tryea
         jsr   IDEA
         bcs   .notea
         jmp   foundea

.notea
;
; Try to identify David-DOS bootloader
; (no special behavior for now because all samples I have are
; handled by built-in RWTS, so no need to trace)
;
         jsr   IDDavid
         bcs   .notdavid
         lda   #s_daviddos
         jsr   PrintByID
.notdavid
.useuniv
;
; We didn't recognize the boot sector, so use the universal
; (built-in) RWTS and hope for the best
;
         jmp   UseUniversal
}

;-------------------------------
; AnalyzeT00
; set additional flags based on contents of track $00
;
; in:    Track $00 in data buffer
; out:   gIsBoot1, gIsMaster, gIsRWTS set to #TRUE or #FALSE
;        all flags clobbered
;        all registers clobbered
;-------------------------------
!zone {
AnalyzeT00
         lda   #$01
         ldx   #$00
         ldy   #$38
         jsr   compare    ; if T00,S01,$00 ==
         !byte $8E,$E9,$B7,$8E,$F7,$B7,$A9,$01
         !byte $8D,$F8,$B7,$8D,$EA,$B7,$AD,$E0
         !byte $B7,$8D,$E1,$B7,$A9,$02,$8D,$EC
         !byte $B7,$A9,$04,$8D,$ED,$B7,$AC,$E7
         !byte $B7,$88,$8C,$F1,$B7,$A9,$01,$8D
         !byte $F4,$B7,$8A,$4A,$4A,$4A,$4A,$AA
         !byte $A9,$00,$9D,$F8,$04,$9D,$78,$04
         ldx   #TRUE
         bcc   .boot1
         ldx   #FALSE
.boot1
         stx   gIsBoot1

         lda   #$01
         ldx   #$00
         ldy   #$38
         jsr   compare    ; if T00,S01,$00 ==
         !byte $8E,$E9,$37,$8E,$F7,$37,$A9,$01
         !byte $8D,$F8,$37,$8D,$EA,$37,$AD,$E0
         !byte $37,$8D,$E1,$37,$A9,$02,$8D,$EC
         !byte $37,$A9,$04,$8D,$ED,$37,$AC,$E7
         !byte $37,$88,$8C,$F1,$37,$A9,$01,$8D
         !byte $F4,$37,$8A,$4A,$4A,$4A,$4A,$AA
         !byte $A9,$00,$9D,$F8,$04,$9D,$78,$04
         ldx   #TRUE
         bcc   .master
         ldx   #FALSE
.master
         stx   gIsMaster

         lda   #$07
         ldx   #$00
         ldy   #$40
         jsr   compare    ; if T00,S07,$00 ==
         !byte $84,$48,$85,$49,$A0,$02,$8C,$F8
         !byte $06,$A0,$04,$8C,$F8,$04,$A0,$01
         !byte $B1,$48,$AA,$A0,$0F,$D1,$48,$F0
         !byte $1B,$8A,$48,$B1,$48,$AA,$68,$48
         !byte $91,$48,$BD,$8E,$C0,$A0,$08,$BD
         !byte $8C,$C0,$DD,$8C,$C0,$D0,$F6,$88
         !byte $D0,$F8,$68,$AA,$BD,$8E,$C0,$BD
         !byte $8C,$C0,$A0,$08,$BD,$8C,$C0,$48
         ldx   #TRUE
         bcc   .rwts
         ldx   #FALSE
.rwts
         stx   gIsRWTS
         rts
}
