; MLI command codes
CMD_CREATE =   $C0        ; create new file
CMD_DESTROY =  $C1        ; delete a file
CMD_GETFILEINFO = $C4     ; get file (or volume) info
CMD_ONLINE =   $C5        ; check online volume(s)
;CMD_SETPREFIX = $C6       ; change default pathname prefix
CMD_OPEN =     $C8        ; open a file
;CMD_NEWLINE =  $C9        ; set line-by-line read mode
CMD_READ =     $CA        ; read an open file
CMD_WRITE =    $CB        ; write to an open file
CMD_CLOSE =    $CC        ; close an open file
CMD_SETMARK =  $CE        ; change position in an open file
CMD_SETEOF  =  $D0        ; set file size

; MLI parameter counts
PC_CREATE =    $07
PC_DESTROY =   $01
PC_GETFILEINFO = $0A
PC_ONLINE =    $02
;PC_SETPREFIX = $01
PC_OPEN  =     $03
;PC_NEWLINE =   $03
PC_READ  =     $04
PC_WRITE =     $04
PC_CLOSE =     $01
PC_SETMARK =   $02
PC_SETEOF  =   $02

PRODOSMLI =    $BF00      ; [callable] MLI entry point

!ct "lcase.ct"
RAMFileName    !text "PASSPORTTMP.DSK"
RAMFileName_e

HardDirName    !text "PASSPORT"
HardDirName_e

HardDiskName    !text "/IMG0000.DSK"
HardDiskName_e

; MLI error codes
ERR_FNF  =     $46
ERR_EOF  =     $4C
ERR_EXIST =    $47

;-------------------------------
; WriteTrackMLI - write the contents of
;   BASEPAGE data buffer to disk
; in:  @SLOT contains (slot x 16) + $30
;      @DRIVE contains drive + $30
;      @gTrack contains track number
;      @BASEPAGE contains data to write ($1000 bytes)
; out: if C set, write failed (A contains MLI error code)
;      if C clear, write succeeded (A is clobbered)
;      all other flags clobbered
;      all registers clobbered
;-------------------------------
!zone {
WriteTrackMLI
         jsr   SwapProDOS
         lda   gUsingHardDisk
         and   gUsingRAMDisk
         beq   +
         jsr   ReorderBuffer
+
; ProDOS 'unit number' is DSSS0000, where
; D is the drive number (0=drive 1, 1=drive 2) and
; SSS is the slot number (1-7)
; c.f. 'Beneath Apple ProDOS' page 6-19
;
         lda   DRIVE      ; drive number is stored as ASCII text
         sec
         sbc   #$31
         lsr
         lda   #0
         ror
         sta   mliparam+1
         lda   SLOT
         asl
         asl
         asl
         asl
         ora   mliparam+1
         sta   mliparam+1 ; ProDOS unit number
         lda   #$00
         sta   mliparam+2 ; lo byte of data buffer
         lda   #$08
         sta   .blockcount
         lda   gTrack
         asl
         asl
         asl
         sta   mliparam+4 ; lo byte of block number
         rol
         and   #$01
         sta   mliparam+5 ; hi byte of block number
         lda   #BASEPAGE  ; hi byte of data buffer
         sta   mliparam+3
.writeloop
         lda   gUsingHardDisk
         and   gUsingRAMDisk
         beq   +
         lda   #$81       ; 'write block' command
         ldy   #$03       ; parameter count
         jsr   mli
         bcs   .writeerr
-        inc   mliparam+3 ; 2 pages per block
         inc   mliparam+3
         inc   mliparam+4
         dec   .blockcount
         bne   .writeloop
         clc
         bcc   .writedone

+        jsr   WriteToFile
         bcc   -

.writeerr
.writedone
         php
         pha
         lda   gUsingHardDisk
         and   gUsingRAMDisk
         beq   +
         jsr   ReorderBuffer
+        jsr   SwapProDOS
         pla
         plp
         rts

.blockcount !byte $FF
}

;-------------------------------
; SaveFile1Shot
; save a file to disk all at once,
;   using ProDOS MLI calls
;
; in:  stack contains 11 ($0B) bytes of parameters:
;      +1 address of pathname
;      +3 [byte] file type
;      +4 [word] aux file type
;      +6 address of data buffer
;      +8 [word] length of data buffer
;      +A address of ProDOS file buffer
; out: if C set, save failed and A contains error code
;        from open or write
;      if C clear, save succeeded
;      all other flags clobbered
;      all registers clobbered
;      stack set to next instruction after parameters
;-------------------------------
!zone {
SaveFile1Shot
         clc
         pla
         sta   $00
         adc   #$0B
         tax
         pla
         sta   $01
         adc   #$00
         pha
         txa
         pha

         ldy   #$01
         lda   ($00),y    ; lo byte of pathname
         sta   mliparam+1
         iny
         lda   ($00),y    ; hi byte of pathname
         sta   mliparam+2
         jsr   DeleteFile ; don't care if this fails
         ldy   #$03
         lda   ($00),y    ; file type
         sta   mliparam+4
         iny
         lda   ($00),y    ; lo byte of aux file type
         sta   mliparam+5
         iny
         lda   ($00),y    ; hi byte of aux file type
         sta   mliparam+6
         jsr   CreateFile
         bcs   .savefile1s

         ldy   #$0A
         lda   ($00),y    ; lo byte of ProDOS file buffer
         sta   mliparam+3
         iny
         lda   ($00),y    ; hi byte of ProDOS file buffer
         sta   mliparam+4
         jsr   OpenFile
         bcs   .savefile1s

         pha              ; push file reference number
         ldy   #$06
         lda   ($00),y    ; lo address of data buffer
         sta   mliparam+2
         iny
         lda   ($00),y    ; hi address of data buffer
         sta   mliparam+3
         iny
         lda   ($00),y    ; lo data length
         sta   mliparam+4
         iny
         lda   ($00),y    ; hi data length
         sta   mliparam+5
         pla              ; pull file reference number
         jsr   WriteFile
         php              ; save flags from writefile
         pha
         jsr   CloseFile  ; always close whether write worked or not
         pla
         plp              ; restore flags from write
                          ; (so caller gets codes from write attempt,
                          ; not close)

.savefile1s
         rts
}

;-------------------------------
; open file via ProDOS MLI
;
; in:  caller has filled @mliparam with address of
;        pathname, address of data buffer, and maximum
;        data length
; out: if C set, open failed and A contains error code
;      if C clear, open succeeded and A contains
;        file reference number
;-------------------------------
!zone {
OpenFile
         lda   #CMD_OPEN  ; MLI command
         ldy   #PC_OPEN   ; number of parameters for 'open' command
         jsr   mli
         bcs   .openfile
         lda   refnum     ; caller should save file reference number
                          ; as this memory location may be
                          ; overwritten by later MLI calls
.openfile
         rts
}

;-------------------------------
; read an open file via ProDOS MLI
;
; in:  A = file reference number
;      caller has filled @mliparam with address of
;        data buffer and maximum data length
; out: if C set, read failed and A contains error code
;      if C clear, read succeeded and A contains the same
;        file reference number that was passed in
;-------------------------------
!zone {
ReadFile
         sta   mliparam+1 ; store file reference number
         lda   #CMD_READ  ; MLI read command
         ldy   #PC_READ   ; number of parameters for 'read' command
         jsr   mli
         bcs   .readfile
         lda   mliparam+1 ; if no error, return file reference number
.readfile
         rts
}

;-------------------------------
; change file position in an open file via ProDOS MLI
;
; in:  A = file reference number
;      caller has filled @mliparam+2/+3/+4 with
;        new file position
; out: if C set, set_mark call failed and A contains error code
;      if C clear, set_mark call succeeded and A contains
;        the same file reference number that was passed in
;-------------------------------
!zone {
SetMark
         sta   mliparam+1 ; store file reference number
         lda   #CMD_SETMARK ; MLI set_mark command
         ldy   #PC_SETMARK ; number of params for 'set_mark' cmd
         jsr   mli
         bcs   .exit
         lda   mliparam+1 ; if no error, return file refnum
.exit    rts
}

;-------------------------------
; write to an open file via ProDOS MLI
;
; in:  A = file reference number
;      caller has filled @mliparam with address of
;        data buffer and data length
; out: if C set, write failed and A contains error code
;      if C clear, write succeeded and A contains the same
;        file reference number that was passed in
;-------------------------------
!zone {
WriteFile
         sta   mliparam+1 ; store file reference number
         lda   #CMD_WRITE ; MLI write command
         ldy   #PC_WRITE  ; number of parameters for 'write' command
         jsr   mli
         bcs   .writefile
         lda   mliparam+1 ; if no error, return file reference number
.writefile
         rts
}

;-------------------------------
; set file size in an open file via ProDOS MLI
;
; in:  A = file reference number
;      caller has filled @mliparam+2/+3/+4 with
;        new file size
; out: if C set, set_eof call failed and A contains error code
;      if C clear, set_eof call succeeded and A contains
;        the same file reference number that was passed in
;-------------------------------
!zone {
SetEOF
         sta   mliparam+1 ; store file reference number
         lda   #CMD_SETEOF ; MLI set_eof command
         ldy   #PC_SETEOF ; number of params for 'set_eof' cmd
         jsr   mli
         bcs   .exit
         lda   mliparam+1 ; if no error, return file refnum
.exit    rts
}

;-------------------------------
; close an open file
; in:  A = file reference number
; out: if error, C set and A contains error code
;      if success, C clear
;-------------------------------
CloseFile
         sta   mliparam+1 ; store file reference number
         lda   #CMD_CLOSE ; MLI close command
         ldy   #PC_CLOSE  ; number of parameters for 'close' command
         jsr   mli
         rts

;-------------------------------
; create a directory or file via ProDOS MLI
; always sets access bits to $C3 (full access)
; always sets creation to 0 (current date/time)
; always sets storage type to $0D (directory) or 1 (file)
; in:  caller has filled @mliparam
;        with address of pathname,
;        file type, aux file type
; out: if error, C set and A contains error code
;      if success, C clear
;-------------------------------
accessbits =   $C3        ; full access

CreateDir
         lda   #$0D
         ldy   #$0F
         bne   .createFile
CreateFile
         lda   #1
         ldy   #6
.createFile
         sta   mliparam+7 ; storage type (directory or file)
         sty   mliparam+4 ; file type (directory or binary)
         lda   #accessbits
         sta   mliparam+3 ; access bits (full access)
         lda   #0
         sta   mliparam+8 ; creation date (current)
         sta   mliparam+9
         sta   mliparam+10 ; creation time (current)
         sta   mliparam+11
         lda   #CMD_CREATE ; MLI create command
         ldy   #PC_CREATE ; number of parameters for 'create' command
         jsr   mli
         rts

;-------------------------------
; delete a file using ProDOS MLI
; in:  caller has filled @mliparam
;        with address of pathname
; out: if error, C set and A contains error code
;      if success, C clear
;-------------------------------
DeleteFile
         lda   #CMD_DESTROY ; MLI destroy command
         ldy   #PC_DESTROY ; number of parameters for 'destroy' command
         jsr   mli
         rts

;-------------------------------
; CreateRAMOrHardFile - create image file on RAM or hard disk
;   if RAM or hard disk is in use
; in:  nothing (assumes that prefix is set already)
; out: if C set, write failed (A contains MLI error code)
;      if C clear, write succeeded (A is clobbered)
;      all other flags clobbered
;      all registers clobbered
;-------------------------------
!zone {
CreateRAMOrHardFile
         lda   gUsingHardDisk
         lsr              ; TRUE/FALSE in C instead of Z
         bcc   .createHardFile
         lda   gUsingRAMDisk
         beq   .createRAMFile

.gotRAM
         rts

.createRAMFile
         ;existing file being reused?

         lda   gRAMDiskRef
         bne   .gotRAM

         ;no, create a new one

.createHardFile
         php
         jsr   SwapProDOS
         lda   OnlineReturn
         and   #$0F
         tay
         plp
         php
         bcs   .prefRAM
         clc
         adc   #(HardDirName_e-HardDirName)+2
         sta   DiskImgPath
         tax
         lda   #$2F
         sta   DiskImgPath+1
         sta   DiskImgPath+2,y
-        lda   OnlineReturn,y
         sta   DiskImgPath+1,y
         dey
         bne   -
         ldy   #(HardDirName_e-HardDirName)
-        lda   HardDirName-1,y
         sta   DiskImgPath,x
         dex
         dey
         bne   -
         jsr   CreateHardDir

         clc
         lda   DiskImgPath
         adc   #(HardDiskName_e-HardDiskName)
         sta   DiskImgPath
         tax
         ldy   #(HardDiskName_e-HardDiskName)
-        lda   HardDiskName-1,y
         sta   DiskImgPath,x
         dex
         dey
         bne   -

.findSpare
         jsr   GetFileInfo
         bcs   .foundSpare
         ldx   DiskImgPath

.nextDigit
         inc   DiskImgPath-4,x
         lda   DiskImgPath-4,x
         cmp   #'9'+1
         bcc   .findSpare
         lda   #'0'
         sta   DiskImgPath-4,x
         dex
         bne   .nextDigit

.prefRAM
         clc
         adc   #(RAMFileName_e-RAMFileName)+1
         sta   DiskImgPath
         tax
         lda   #$2F
         sta   DiskImgPath+1,y
-        lda   OnlineReturn,y
         sta   DiskImgPath,y
         dey
         bne   -
         ldy   #(RAMFileName_e-RAMFileName)
-        lda   RAMFileName-1,y
         sta   DiskImgPath,x
         dex
         dey
         bne   -
         jsr   DeleteRAMFile
.foundSpare
         jsr   CreateFile
         bcs   .createfail
         lda   #0
         sta   mliparam+3
         lda   #8
         sta   mliparam+4
         jsr   OpenFile
         bcs   .openfail

         plp
         php
         bcc   .storeHardRef
         sta   gRAMDiskRef
         bcs   .setSize

.storeHardRef
         sta   gHardDiskRef

.setSize
         ;140kb

         ldx   #0
         stx   mliparam+2
         ldx   #$30
         stx   mliparam+3
         ldx   #2
         stx   mliparam+4
         jsr   SetEOF
         lda   #0
         rol

         ;update file buffer array

         plp
         pha
         php
         jsr   SaveGlobal
         plp
         pla
         beq   .restore

         php
         lda   gRAMDiskRef
         bcs   .closeRef
         lda   gHardDiskRef
         ldx   #0
         stx   gHardDiskRef

.closeRef
         jsr   CloseFile

.openfail
         plp
         php
         pha
         jsr   DeleteFile
         pla

.createfail
         plp
         bcs   .failRAM
         jsr   SwapProDOS
         jmp   FatalWriteError

.failRAM
         ldx   #FALSE
         stx   gUsingRAMDisk

.restore
         php
         pha
         jsr   SwapProDOS
         pla
         plp

.done
         rts

DiskImgPath
         !byte $d1
         !fill 17
         !fill HardDirName_e-HardDirName
         !fill HardDiskName_e-HardDiskName

}

;-------------------------------
; WriteToFile - write memory to image file on RAM or hard disk
;   if RAM or hard disk is in use
; in:  called has filled @mliparam
;        with block number and write address
; out: if error, C set and A contains error code
;      if success, C clear
;      all other flags clobbered
;      all registers clobbered
;-------------------------------
!zone {
WriteToFile
         lda   mliparam+2
         pha
         lda   mliparam+3
         pha

         lda   mliparam+4
         sta   .tmpparm4
         asl
         sta   mliparam+3
         lda   mliparam+5
         sta   .tmpparm5
         rol
         sta   mliparam+4
         lda   #0
         sta   mliparam+2
         lda   gHardDiskRef
         bne   +
         lda   gRAMDiskRef
+        jsr   SetMark
         tax
         pla
         sta   mliparam+3
         pla
         sta   mliparam+2
         txa
         bcs   .done
         lda   #0
         sta   mliparam+4
         lda   #2
         sta   mliparam+5
         lda   gHardDiskRef
         bne   +
         lda   gRAMDiskRef
+        jsr   WriteFile

.done
         pha
         lda   .tmpparm4
         sta   mliparam+4
         lda   .tmpparm5
         sta   mliparam+5
         pla
         rts

.tmpparm4 !byte 0
.tmpparm5 !byte 0
}

;-------------------------------
; WriteRAMToDisk - write image file in RAM to physical disk
;   if RAM disk is in use
; in:  nothing
; out: if error, C set and A contains error code
;      if success, C clear
;      all other flags clobbered
;      all registers clobbered
;-------------------------------
!zone {
WriteRAMToDisk
         lda   #0
         sta   mliparam+2
         sta   mliparam+3
         sta   mliparam+4
         sta   gTrack
         jsr   SwapProDOS
         lda   gRAMDiskRef
         jsr   SetMark
         jsr   SwapProDOS

         jsr   RestartProgress       ; restart progress bar
         lda   #FALSE
         sta   gUsingRAMDisk         ; prevent track write from calling RAM again

-        lda   #0
         sta   mliparam+2
         sta   mliparam+4
         lda   #$10
         sta   mliparam+3
         sta   mliparam+5
         jsr   SwapProDOS
         lda   gRAMDiskRef
         jsr   ReadFile
         jsr   SwapProDOS
         jsr   IncProgress
         jsr   WriteTrackMLI
         bcs   .exit
         lda   KEY
         bmi   .cancel
         inc   gTrack
         lda   gTrack
         cmp   #$23
         bne   -

         jsr   IncProgress
         clc

.exit
         ldx   #TRUE
         stx   gUsingRAMDisk
         rts

.cancel
         lda   #TRUE
         sta   gUsingRAMDisk
         jmp   Cancel

}

;-------------------------------
; (Close)DeleteRAMFile - (close and) remove image file on RAM disk
;   if RAM disk is in use
; in:  nothing
; out: if error, C set and A contains error code
;      if success, C clear
;      all other flags clobbered
;      all registers clobbered
;-------------------------------
!zone {
CloseDeleteRAMFile
         lda   gRAMDiskRef
         jsr   CloseFile
         lda   #0
         sta   gRAMDiskRef
DeleteRAMFile
         lda   #<DiskImgPath
         sta   mliparam+1
         lda   #>DiskImgPath
         sta   mliparam+2
         jmp   DeleteFile
}


;-------------------------------
; CreateHardDir - create images directory on hard disk
;   if hard disk is in use
; in:  nothing
; out: if error, C set and A contains error code
;      if success, C clear
;      all other flags clobbered
;      all registers clobbered
;-------------------------------
!zone {
CreateHardDir
         lda   #<DiskImgPath
         sta   mliparam+1
         lda   #>DiskImgPath
         sta   mliparam+2
         jmp   CreateDir
}


;-------------------------------
; get volume name of disk in specific slot+drive
; in:  A = unit number (DSSS0000)
; out: if no disk in drive or any MLI error, C set and A contains error code
;      if disk found, C clear and @VolumeName contains volume name
;      (up to 15 character name, no leading slash)
;      note: lower 4 bits of @OnlineReturn contain length of @VolumeName
;-------------------------------
!zone {
GetVolumeName
         sta   mliparam+1
         lda   #<OnlineReturn
         sta   mliparam+2
         lda   #>OnlineReturn
         sta   mliparam+3
         bne   Online
OnlineReturn
         !byte $FF
VolumeName
         !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF
         !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
}

;-------------------------------
; check if volume is online
; using ProDOS MLI
; in:  caller has filled @mliparam
;        with unit number
; out: if error, C set and A contains error code
;      if success, C clear
;-------------------------------
Online
         lda   #CMD_ONLINE
         ldy   #PC_ONLINE
         jsr   mli
         rts

;-------------------------------
; query volume information
; using ProDOS MLI
; in:  nothing (queries last fetched volume)
; out: if error, C set and A contains error code
;      if success, C clear and MLI buffer is filled
;      (access, file type, block count, dates and times)
;-------------------------------
GetVolumeInfo
         lda   OnlineReturn
         and   #$0F
         tax
         inx
         stx   OnlineReturn
         tay
-        lda   OnlineReturn,y
         sta   VolumeName,y
         dey
         bne   -
         lda   #$2F ;'/'
         sta   VolumeName
         lda   #<OnlineReturn
         sta   mliparam+1
         lda   #>OnlineReturn
         sta   mliparam+2

GetFileInfo
         lda   #CMD_GETFILEINFO
         ldy   #PC_GETFILEINFO
         jsr   mli
         rts

;-------------------------------
; low-level MLI wrapper
; in:  A = MLI command code
;      Y = number of MLI parameters
;      caller has filled @mliparam
;        with all relevant parameters
; out: returns immediately after
;        calling MLI, so whatever
;        state the MLI routine sets,
;        the caller will see it
;        verbatim
;-------------------------------
mli      sta   mlicmd     ; store command code
         sty   mliparam   ; number of parameters
         jsr   PRODOSMLI  ; call ProDOS
mlicmd   !byte 00         ; command number
         !word mliparam   ; address of parameter table
         rts
mliparam !byte $FE,$FE,$FE
access   !byte $FE        ; access privileges (set by MLI get_file_info)
filetype !byte $FE        ; file type (set by MLI get_file_info)
auxtype                   ; auxiliary file type (2 bytes, set by MLI get_file_info)
refnum   !byte $FE        ; file refnum (set by MLI open)
mlilen   !byte $FE,$FE    ; file length (set by MLI read)
blocks   !byte $FE,$FE    ; blocks used (set by getvolumeinfo)
                          ; member is also used by createfile
         !byte $FE,$FE,$FE,$FE,$FE,$FE,$FE,$FE
                          ; used by get_file_info
