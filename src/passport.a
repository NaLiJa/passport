!cpu 6502
!ifdef RELBASE {
*=RELBASE
} else {
*=$2000
}

;-------------------------------
; Passport
; a 4am hack
; (c) 2016-2020 by 4am
;
; Permission is hereby granted, free of charge, to any
; person obtaining a copy of this software and associated
; documentation files (the "Software"), to deal in the
; Software without restriction, including without limitation
; the rights to use, copy, modify, merge, publish,
; distribute, sublicense, and/or sell copies of the
; furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice
; shall be included in all copies or substantial portions of
; the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
; KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
; WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
; OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
; OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
; SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;
;-------------------------------

!ifndef VERBOSE {
VERBOSE  = $00       ; set to $01 to display API label addresses
}

!to "../build/PASSPORT.TMP",plain

;-------------------------------
; Addresses we read/call
TEXTTOP  =     $22
VPOS     =     $25
MLI      =     $BF00
REBOOT   =     $FAA6
TEXT     =     $FB2F
MACHINEID =    $FBB3
HOME     =     $FC58
WAIT     =     $FCA8
PRBYTE   =     $FDDA
COUT     =     $FDED
PR0      =     $FE89
IN0      =     $FE93

;Universal RWTS-specific values
UNIV_A1 = $B956           ; must LSR before setting
UNIV_A2 = $B95F
UNIV_A3 = $B968
UNIV_D1 = $B8E7
UNIV_D2 = $B8F1
UNIV_D3 = $B8FC

!source "apidefs.a"

FirstMover
         jmp    ResetVector

         !source "strings/en.a"
         !source "analyze.a"
         !source "id/inspect0.a"
         !source "id/precheck.a"
         !source "id/trace.a"
         !source "id/trace33.a"
         !source "id/trace32.a"
         !source "id/trace8b3.a"
         !source "id/trace33p.a"
         !source "id/dos33.a"
         !source "id/prodos.a"
         !source "id/pascal.a"
         !source "id/rdos.a"
         !source "id/jsr8b3.a"
         !source "id/mecc.a"
         !source "id/datasoft.a"
         !source "id/tsr.a"
         !source "id/protecteddos.a"
         !source "id/encode44.a"
         !source "id/encode53.a"
         !source "id/ea.a"
         !source "id/milliken.a"
         !source "id/daviddos.a"
         !source "id/quickdos.a"
         !source "id/diversidos.a"
         !source "id/prontodos.a"
         !source "id/d5d5f7.a"
         !source "id/laureate.a"
         !source "id/micrograms.a"
         !source "id/volumename.a"
         !source "id/dinkeydos.a"
         !source "id/advent.a"
         !source "id/panglosdos.a"
         !source "id/davidson.a"
         !source "id/holle.a"
         !source "id/phoenix.a"
         !source "print.a"
         !source "compare.a"
         !source "modify.a"
         !source "memory.a"
         !source "sectormap.a"
         !source "mli.a"
         !source "ramdisk.a"
         !source "harddisk.a"
         !source "slots.a"
         !source "prefs.a"
         !source "keys.a"
         !source "cffa.a"
         !source "rwts.a"
         !source "standarddelivery.a"

ResetVector
         lda   $C0E8
         jsr   PR0
         jsr   IN0
         sta   $C000
         sta   $C002
         sta   $C004
         sta   $C00C
         sta   $C00E
         jsr   ThisSlot
         ; /!\ execution falls through here

MainMenu
         lda   #<ResetVector
         sta   $03F2
         lda   #>ResetVector
         sta   $03F3
         eor   #$A5
         sta   $03F4
         ldx   #$FF
         txs
         jsr   ClearScreen
         lda   #s_header
         jsr   PrintByID
         lda   #s_mainmenu
         jsr   PrintByID
         bit   gTargetType
         bmi   @usingHardDisk
         bvs   @usingCFFA
         lda   #s_targetdisk
         !byte $2C
@usingCFFA
         lda   #s_targetcffa
         !byte $2C
@usingHardDisk
         lda   #s_targetfile
         jsr   PrintByID
@getkey
         jsr   WaitForKey
         cmp   #$80
         bne   +
         jsr   EnterCFFAIfAvailable
         bcc   ResetVector
         bcs   @getkey

+        cmp   #$9B                  ; Esc quits
         beq   @jumpToExit
         cmp   #$91                  ; Ctrl-Q quits
         beq   @jumpToExit
         cmp   #k_quit
         bne   +
@jumpToExit
         jmp   CleanExit

+        cmp   #k_slot
         bne   +
         jsr   NextSlot
         lda   #TRUE
         sta   gChangedPrefs
         beq   MainMenu              ; always branches

+        cmp   #k_verify
         bne   +
         lda   #%00000000
         beq   Action                ; always branches

+        cmp   #k_crack
         bne   @getkey
         lda   #%11000000
         ; /!\ execution falls through here

Action
         sta   gMode
         jsr   InitSectorMap
Reaction
         lda   #FALSE
         sta   gTriedUniv
         sta   gSaidWriting
         sta   gIsProtDOS
         sta   gIsInfocom18
         sta   gIs13Sector
         lda   #$00
         sta   gTrack
         sta   gSector
         sta   gPatchCount
         sta   jCallRWTS+1
         lda   #$08
         sta   gAddress+1
         jsr   ShowInitialProgressScreen

         lda   gMode
         bpl   @printReading         ; don't create RAM disk or hard disk file in verify mode
         jsr   LookupUnitNumberOfSelectedHardDisk
         beq   @notHardDrive
         jsr   SwapProDOS            ; ProDOS out -> in
         jsr   CreateFileOnHardDisk
         jsr   SwapProDOS            ; ProDOS in -> out (preserves flags)
         bcc   @printReading
         jmp   FatalWriteError       ; failed to create target file on hard disk
                                     ; this is fatal
@notHardDrive
         lda   RAMDiskImagePath
         beq   @printReading         ; no RAM disk available
         jsr   SwapProDOS            ; ProDOS out -> in
         jsr   CreateFileOnRAMDisk
         jsr   SwapProDOS            ; ProDOS in -> out (preserves flags)
         bcc   @printReading
         lda   #0                    ; failed to create temporary file on RAM disk
         sta   RAMDiskImagePath      ; this is not fatal, but we'll mark the RAM
                                     ; disk as unavailable so we don't bother with it
@printReading
         lda   #s_reading
         jsr   PrintByID
         lda   #$B2
         ldx   #$00
         ldy   #$0D
         jsr   ClearMemory
         jsr   CopyUniversal
         jsr   IgnoreAddressChecksum
         jsr   ReadSector
         bcc   +
         jsr   IDBootFailure ; /src/id/inspect0
         bcc   +
         lda   #s_fail
         jsr   PrintByID
         lda   #s_fatal0000
         jsr   PrintByID
         jmp   TheEnd
+        jmp   IDBootloader ; /src/id/inspect0






;
; We are now fairly confident that the RWTS in memory
; is normal enough to call, Advanced Demuffin style.
;
ADStyle
         jsr   IncProgress
         lda   #s_diskrwts
         jsr   PrintByID
;
; Check for protections in early boot that
; might indicate intentional bad sectors
; elsewhere in the disk that we should skip,
; or changes we need to make to the RWTS
; before we start.
;
         jsr   xHeredityDog
         bcs   +
         lda   #$05
         sta   gDisplayBytes
         lda   #s_lockitup
         jsr   PrintByID
+
         jsr   xSunburst
         bcs   +
         lda   #$04
         sta   gDisplayBytes
         lda   #s_sunburst
         jsr   PrintByID
+
         jsr   xOptimumRes
         bcs   +
         lda   #TRUE
         sta   gIsOptimum
         lda   #s_optimum
         jsr   PrintByID
+
         jsr   xSVE
         bcs   +
         lda   #s_sve
         jsr   PrintByID
         lda   #$CA
         sta   $BE5B
         lda   #$B6
         sta   $BE5C
+
         jsr   xRPS
         bcs   +
         lda   #$01
         sta   gDisplayBytes
         lda   #s_rps
         jsr   PrintByID
+
         jsr   xB660
         jsr   xB4BB
         jsr   xHarvey
         jmp   ReadWithRWTS

UseUniversal
         jsr   IncProgress
         jsr   StartWithUniv
;
; On Dinkey-DOS disks (e.g. Ultima V, Times of Lore), we start with the
; universal RWTS then apply a patch in memory.
; These disks use a hybrid RWTS that alters the sector number in the
; address field based on the address epilogue. Once we normalize the
; sector numbers, no further patches are required, since the RWTS can also
; read unprotected disks. A separate patcher finds the actual code that
; alters the sector number to print it to the log.
;
         lda   gIsDinkeyDOS
         bne   +
         jsr   PatchUniversalRWTSForOrigin
         bmi   ReadWithRWTS          ; always branches
;
; On TSR disks (e.g. Dawn Patrol, Dungeon), we start with the universal
; RWTS then apply a patch in memory.
;
+        lda   gIsTSR
         bne   +
         jsr   PatchUniversalRWTSForTSR
;
; On pure 13-sector disks, we just hijack the read routine to perform a
; verification instead.
;
+        lda   gIs13Sector
         bne   +
         lda   #<read13
         sta   jCallRWTS+1
         lda   #>read13
         sta   jCallRWTS+2
         bne   ReadWithRWTS          ; always branches
;
; On other disks that use the universal RWTS for the entire disk, we use
; an adaptive RWTS that accepts any epilogue on the first sector but then
; enforces all other sectors to have the same epilogue.
;
+        jsr   PatchUniversalRWTSForAdaptive
;
; Disable drive recalibration on bad sectors so we give up on bad sectors
; faster and detect unformatted or specially structured tracks faster.
;
         jsr   PatchUniversalRWTSForNoRecal
;
; Some disks have different epilogues on track 0, so we stop using the
; adaptive RWTS so we don't falsely accuse those disks of being damaged.
;
         lda   #kSectorResetAdaptiveRWTS
         sta   T00S0F
;
; Some disks have an intentionally invalid checksum on T00,S00 (read by
; the drive firmware, which doesn't verify it).
;
         lda   #kSectorIgnoreAddressChecksum
         sta   T00S00
;
; note: execution falls through here
;
ReadWithRWTS
         lda   #$22
         jsr   ChangeTrackNW
         lda   #$0F
         ldx   gIs13Sector
         bne   +
         lda   #$0C
+        jsr   ChangeSector
         lda   #<T22S0F
         sta   checksector+1
         lda   #>T22S0F
         sta   checksector+2
.read
         lda   KEY
         bpl   .checkinfocom
         bit   STROBE
         cmp   #$e0 ;ignore backtick (MAME debug break)
         beq   .checkinfocom
         jmp   Cancel
.checkinfocom
         lda   gIsInfocom18
         bne   checksector
         jsr   VerifyInfocom18
         bcc   .passtrack
         jmp   FatalError
.passtrack
         jmp   .prevtrack

checksector
         lda   $FFFF                            ; status of current sector in sector map (modified above)
         cmp   #kSectorCustomFirst              ; call a custom routine before deciding what to do with this sector?
         bcc   +
         cmp   #kSectorCustomLast
         bcs   +
         jsr   PreReadSector
+        pha                                    ; replace status (on stack) with new status returned from PreReadSector
         cmp   #kSectorIgnore                   ; skip this sector?
         beq   nextsector
         cmp   #kSectorSwitchToBuiltinRWTS      ; switch to built-in RWTS before reading this sector?
         bne   +
         lda   gTriedUniv
         beq   +
         jsr   SwitchToUniv
+        jsr   ReadSector
         bcc   nextsector
;
; Uh oh, we got a read error. But do we care?
; If we just got to this track, check for whole-track protections.
;
         ldx   #$0F ;16-sector
         lda   gIs13Sector
         beq   .expect13
         lda   gIsDOS32
         bne   +
.expect13
         ldx   #$0C ;13-sector
+        cpx   gSector
         bne   .checkoptional
         stx   .sub+1
         jsr   SkipTrack
         bcs   .checkoptional
; Skip this track (we already printed the reason)
         lda   #$00
         jsr   ChangeSector
         lda   checksector+1
         sec
.sub     sbc   #$0F ;self-modified according to sectors per track
         sta   checksector+1
         bcs   +
         dec   checksector+2
+        jmp   nextsector

; do this only *after* checking for track-skip
; to avoid fatal errors on unformatted tracks

.checkoptional
         pla
         pha
;
; Maybe we marked this sector as optional based
; on markers in the bootloader.
;
         cmp   #kSectorOptional
         beq   .optional

;
; Otherwise we're in the middle of a track, so try switching to
; the universal RWTS and see if that helps. (Many disks contain
; an RWTS that can't read the early tracks or sectors that
; contain the RWTS code, since those are loaded by the
; disk controller firmware.)
;

.tryuniversal
         lda   gIsDOS32   ; is this a DOS 3.2 disk?
         beq   .fatal     ; yes, so read error is fatal
         lda   gTriedUniv ; have we tried the universal RWTS?
         beq   .maybedavidson ; yes, but check one last thing
         jsr   SwitchToUniv ; no, switch it in now
         jmp   .read      ; and re-read this sector

.maybedavidson
         jsr   IDDavidson
         bcc   .optional

.fatal   pla              ; if we get to here, we've
         jmp   FatalError ; decided the read error is fatal

.optional
         lda   #s_optbad  ; say we're skipping this
         jsr   PrintByID  ; optional sector

; note: execution falls through here

nextsector
         pla
         lda   checksector+1
         bne   .nodec
         dec   checksector+2
.nodec
         dec   checksector+1
         ldy   gSector
         dey
         tya
         jsr   ChangeSector
         lda   gSector
         bmi   .prevtrack
.linkread
         jmp   .read
.prevtrack
         lda   #$0F
         ldx   gIs13Sector
         bne   +
         lda   #$0C
+        jsr   ChangeSector
         ldy   gTrack
         dey
         tya
         jsr   ChangeTrack
         jsr   IncProgress
         lda   gTrack
         bmi   Pass
         cmp   gLastTrack
         bcs   .linkread
Pass
         bit   gMode
         bpl   @passVerify
         lda   gRAMDiskRef
         beq   @printFinalMessage    ; not using RAM disk, so we're done

         ; we've written the entire cracked disk as a file on the RAM disk,
         ; now a second pass to write that file out to the target disk drive
         lda   #s_writingto
         jsr   PrintByID
         lda   #s_slotanddrive
         jsr   PrintByID
         jsr   SwapProDOS            ; ProDOS out -> in
         jsr   WriteRAMToDisk
         jsr   SwapProDOS            ; ProDOS in -> out (preserves flags)
         bcc   @printFinalMessage
         jmp   FatalWriteError

@printFinalMessage
         lda   gPatchCount
         beq   @passWithZeroPatches
         lda   #s_passcrack          ; 'crack complete'
         !byte $2C
@passWithZeroPatches
         lda   #s_passcrack0         ; 'crack complete but no patches'
         !byte $2C
@passVerify
         lda   #s_pass               ; 'verification complete'
         jsr   PrintByID
         jmp   TheEnd

Cancel
         lda   #s_canceled
         jsr   PrintByID
         jmp   TheEnd

FatalError
         lda   #s_fail
         jsr   PrintByID
         lda   gTrack
         cmp   #$22
         bne   TheEnd
.failont22
         lda   gSector
         cmp   #$0F
         beq   .failont22s0f
         ldx   gIsDOS32
         bne   TheEnd
         cmp   #$0C
         bne   TheEnd
.failont22s0f
         lda   #s_fatal220f
         jsr   PrintByID
         ; /!\ execution falls through here

TheEnd
         lda   $C0E8
         jsr   SwapProDOS            ; ProDOS out -> in
         jsr   DeleteFileOnRAMDisk   ; always safe to call
         jsr   CloseFileOnHardDisk   ; always safe to call
         jsr   SwapProDOS            ; ProDOS in -> out
         lda   #s_done
         jsr   PrintByID
         jsr   WaitForKey
         cmp   #$9B
         beq   CleanExit
         cmp   #k_redo
         beq   HandleRedo
         cmp   #k_redo_with_ignore
         beq   HandleRedoWithIgnore
         jmp   MainMenu

HandleRedoWithIgnore
         jsr   InitSectorMapWithIgnore
         jmp   Reaction

HandleRedo
         jsr   ShowInitialProgressScreen
         lda   #s_reading
         jsr   PrintByID
         ; /!\ execution falls through here

;-------------------------------
; RestartScan
; Print 'Restarting scan...' then do exactly that.
; Used by several patchers that find evidence of a protection
; then activate an expensive search the second time around.
; Can be called from anywhere.
; Resets stack, never returns.
; Exits via ReadWithRWTS
;-------------------------------
RestartScan
         lda   #s_restart
         jsr   PrintByID
         jsr   RestartProgress
         jsr   IncProgress
         ldx   #$FF
         txs
         jmp   ReadWithRWTS

CleanExit
         jsr   SwapProDOS            ; ProDOS out -> in
         lda   gChangedPrefs
         bne   +
         jsr   SavePrefs
+        jsr   DeleteFileOnRAMDisk   ; always safe to call
         jsr   MLI                   ; does not return
         !byte $65
         !word +
+        !byte $04

         !source "progress.a"

;-------------------------------
; WriteTrack
;-------------------------------
MLI_IOERR =    $27
MLI_NODEV =    $28
MLI_WRITEPROT = $2B

WriteTrack
         jsr   AnalyzeTrack
WriteTrackNA                         ; entry point used by Special Delivery tracer
                                     ; to write track with 'N'o 'A'nalysis
         bit   gMode
         bpl   @exit                 ; don't write anything in verify mode
         lda   gSaidWriting
         beq   @doTheWriteThing      ; only print 'writing to' message once

         ; we haven't yet printed any 'writing to...' message in the log, so
         ; figure out what that should look like and do it now
         lda   #s_writingto
         jsr   PrintByID

         lda   gHardDiskRef
         beq   @maybeWritingToRAMDisk
         ; we are writing to a file on a hard disk, so print the
         ; full pathname of that file
         jsr   PrintHardDiskImagePath
         bvc   @doneSaidWriting      ; always branches

@maybeWritingToRAMDisk
         lda   gRAMDiskRef
         beq   @notWritingToRAMDisk
         lda   #s_ramdisk            ; writing to (a file on) a RAM disk
         !byte $2C
@notWritingToRAMDisk
         lda   #s_slotanddrive       ; writing to a slot and drive
         jsr   PrintByID

@doneSaidWriting
         lda   #TRUE
         sta   gSaidWriting

@doTheWriteThing
         jsr   SwapProDOS            ; ProDOS out -> in
         jsr   WriteTrackFirstPass
         jsr   SwapProDOS            ; ProDOS in -> out
         bcs   FatalWriteError
@exit    rts

;-------------------------------
; FatalWriteError
; in:    A has MLI code (from WriteTrackFirstPass or WriteTrackSecondPass)
; out:   does not return, exits via TheEnd
;-------------------------------
FatalWriteError
         sta   gDisplayBytes ; for use in error messages, if any
         tax
         lda   #s_writeioerr
         cpx   #MLI_IOERR
         beq   .printerr
         lda   #s_writenodev
         cpx   #MLI_NODEV
         beq   .printerr
         lda   #s_writeprot
         cpx   #MLI_WRITEPROT
         beq   .printerr
         lda   #s_othermli
.printerr
         pha
         lda   #s_writeerr
         jsr   PrintByID
         pla
         jsr   PrintByID
         jmp   TheEnd

;-------------------------------
; ChangeTrack
; in:  A = new track
;-------------------------------
ChangeTrack
         sta   .new+1
         jsr   WriteTrack
.new     lda   #$d1       ; modified at runtime

; note: execution falls through here

ChangeTrackNW             ; "N"o "W"rite
         sta   gTrack
         jsr   ClearTSBuffer
         rts

;-------------------------------
; ChangeSector
; in:  A = new sector
;-------------------------------
ChangeSector
         sta   gSector
         clc
         adc   #BASEPAGE
         sta   gAddress+1
         rts

;-------------------------------
; AnalyzeTrack routine
; Looks at buffer in memory to detect known
; copy protections and disable/revert/modify them
; to work on standard disks.
; Prints through COUT
; Makes modifications in memory only.
; in:  $BASEPAGE page contains one track worth of data
; out: if C set, no known protections were found and
;        no modifications were made
;      if C clear, at least one modification was made
;-------------------------------
AnalyzeTrack
         lda   gTrack
         bne   _applyToAll
_applyToT00
         lda   #>AnalyzeT00
         sta   _byte_hi
         lda   #<AnalyzeT00
         sta   _byte_lo
         clc                                    ; don't show progress UI during decrunch
         jsr   decrunch
         jsr   $2000
_applyToAll
         ; run these modules in verify and crack mode
         !source "patchers/t11diskvol.a"        ; T11 && gIsRWTS only
         !source "patchers/t02volumename.a"     ; T02 && gIsBoot0 only
         bit   gMode
         bmi   +
         jmp   .checkPatchCount
+
         ; only run these modules in crack mode
         !source "patchers/universale7.a"
         !source "patchers/c9ff.a"
         !source "patchers/a6bc95.a"            ; gIsPascal only
         !source "patchers/a5count.a"           ; gIsPascal only
         !source "patchers/d5d5f7.a"            ; gIsPascal || (gIsBoot0 && gPossibleD5D5F7) only
         !source "patchers/prodosrwts.a"        ; gIsProDOS only
         !source "patchers/prodos6a.a"          ; gIsProDOS only
         !source "patchers/prodosmecc.a"        ; gIsProDOS only
         !source "patchers/bbf9.a"              ; gIsProDOS only
         !source "patchers/memory.config.a"     ; gIsProDOS only
         !source "patchers/origin.a"            ; gIsProDOS only
         !source "patchers/rwtsswapmecc.a"      ; gMECCFastloadType || gPossibleMECCSwapper only
         !source "patchers/meccdqc.a"           ; gMECCFastloadType==1 && gT07 only
         !source "patchers/rwtsswappenguin.a"   ; T01 only
         !source "patchers/protecteddos.a"      ; gIsProtDOS only
         !source "patchers/fbff.a"
         !source "patchers/fbffencrypted.a"     ; gIsProDOS only
         !source "patchers/fbffpascal.a"        ; gIsPascal only
         !source "patchers/polarware.a"         ; gIsProDOS only
         !source "patchers/sierra.a"            ; gIsBoot0 only
         !source "patchers/corrupter.a"         ; T13 only
         !source "patchers/ea.a"                ; gIsEA || gIsBoot0 only
         !source "patchers/gamco.a"             ; gPossibleGamco only
         !source "patchers/optimum.a"           ; gIsOptimum only
         !source "patchers/bootcounter.a"       ; T01 only
         !source "patchers/jmpb412.a"           ; T02 only
         !source "patchers/jmp2012.a"           ; T02 only
         !source "patchers/jmpb400.a"           ; T02 && gIsBoot0 only
         !source "patchers/advint.a"            ; gAdventureInternational only
         !source "patchers/jsr8635.a"           ; gIsRWTS only
         !source "patchers/jmpb4bb.a"           ; T02 only
         !source "patchers/dos32muse.a"         ; T01 && gIsDOS32 only
         !source "patchers/sra.a"               ; gIsDOS32 || gIsRWTS only
         !source "patchers/sierra13.a"          ; gIsDOS32 only
         !source "patchers/ssprot.a"            ; gIsF7F6 only
         !source "patchers/f7f6.a"              ; gIsF7F6 only
         !source "patchers/trillium.a"          ; gIsTrillium only
         !source "patchers/trillium2.a"         ; T17 only
         !source "patchers/advent.a"            ; gIsAdvent only
         !source "patchers/davidsonforth.a"     ; gIsDavidson only
         !source "patchers/davidsonasm.a"       ; gIsDavidson only
         !source "patchers/ssi.a"               ; gIsRDOS13 only
         !source "patchers/rdosfmt.a"           ; gIsRDOS13 only
         !source "patchers/aacount.a"
         !source "patchers/hallabs.a"           ; T01 only
         !source "patchers/holle.a"             ; gIsHolle only
         !source "patchers/zoomgrafix.a"        ; gIsPhoenix only
         !source "patchers/e7everywhere.a"      ; gIsBoot0 || gIsProDOS only
         !source "patchers/choplifter.a"        ; gIsChoplifter only
         !source "patchers/pdi.a"               ; gIsDiversi only
         !source "patchers/harvey.a"            ; T01 only
         !source "patchers/tsr.a"               ; T04 && gIsTSR only
         !source "patchers/woodbury.a"          ; gPossibleWoodbury only
         !source "patchers/leisure.a"           ; gIsProDOS && T22 only

.checkPatchCount
         lda   gPatchCount
         beq   .nopatches
         clc
         !byte $24        ; hide next SEC
.nopatches
         sec              ; set carry if nothing happened
         rts

inx6     inx
inx5     inx
inx4     inx
         inx
         inx
         inx
         rts


universalrwts
         !bin "../build/universalrwts.pak"
         !source "exodecrunch.s"

get_crunched_byte:
_byte_lo = * + 1
_byte_hi = * + 2
         lda $1234        ; needs to be set correctly before
                          ; decrunch_file is called.
         inc _byte_lo
         bne _byte_skip_hi
         inc _byte_hi
_byte_skip_hi:
         rts

AnalyzeT00                ; placeholder to identify stack of packed data
         !bin "../build/t00only.pak"
         !source "apicode.a"
LastMover

!if RELBASE = $2000 {
  !ifdef PASS2 {
  } else { ;PASS2
    !set PASS2=1
    !warn "RELBASE = ", HIGHPOINT - (LastMover - FirstMover)
  }
} else {
  !if (HIGHPOINT - (LastMover - FirstMover)) < LOWPOINT {
    !serious "My spoon is too big (", HIGHPOINT - (LastMover - FirstMover), ") is below minimum (", LOWPOINT, ")!"
  } else {
    !warn "LowPoint=", HIGHPOINT - (LastMover - FirstMover)
  }

  !warn "CleanExit=",CleanExit
  !warn "WaitForKey=",WaitForKey
  !warn "SaveProDOS=",SaveProDOS
  !warn "OpenFile=",OpenFile
  !warn "ReadFile=",ReadFile
  !warn "CloseFile=",CloseFile
  !warn "GetVolumeName=",GetVolumeName
  !warn "OnlineReturn=",OnlineReturn
  !warn "VolumeName=",VolumeName
  !warn "RAMDiskImagePath=",RAMDiskImagePath
  !warn "GetVolumeInfo=",GetVolumeInfo
  !warn "mliparam=",mliparam
  !warn "access=",access
  !warn "filetype=",filetype
  !warn "auxtype=",auxtype
  !warn "blocks=",blocks
  !warn "PREFSFILE=",PREFSFILE
  !warn "PREFSBUFFER=",PREFSBUFFER
  !warn "PREFSREADLEN=",PREFSREADLEN
  !warn "PREFSVER=",PREFSVER
  !warn "SavePrefs=",SavePrefs
  !warn "ValidatePrefs=",ValidatePrefs
  !warn "kForceLower=",kForceLower
  !warn "PrintByID=",PrintByID
  !warn "DiskIIArray=",DiskIIArray
  !warn "HardDiskArray=",HardDiskArray
}
